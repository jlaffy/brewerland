% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colourScale.R
\name{colourScale}
\alias{colourScale}
\title{Generate Colour Vectors of Any Length for Any Data Type}
\usage{
colourScale(data, pal = NULL, div = F, bin = F, quantile = F,
  reverse.pal = F, shuffle.pal = F, pal.len = NULL, nbins = 7,
  nquant = 4, levels = NULL, ordered = F, squish = NULL,
  return.legend = F)
}
\arguments{
\item{data}{an atomic vector of type numeric, character or factor.}

\item{pal}{if provided, either a character string of a valid RColorBrewer palette, or a character vector of valid colours. You can check that your palette name is valid in isBrewerPal(), or see all palette names with brewerPalNames() and you can check your vector of colours with areColours(). If not provided, the type of data will be determined internally and a default palette will be returned accordingly.Default: NULL}

\item{div}{a boolean value indicating whether a divergent palette is required. Applicable only to numeric data. Default: F}

\item{bin}{a boolean value indicating whether the data should first be binned (equally-spaced groups) such that all data points within a range of values will share the same colour. Applicable only to numeric data. Default: F}

\item{quantile}{a boolean value indicating whether the data should first be quantised (equally-sized groups) such that all data points within a group will share the same colour. Applicable only to numeric data.  Default: F}

\item{reverse.pal}{a boolean value indicating whether the palette colours should be reversed (prior of course to generating the full data-matched colour vector). Default: F}

\item{shuffle.pal}{a boolean value indicating whether the palette colours should be shuffled (also prior to generating the colour vector). Note that the shuffling of palette colours will be different with each function call. Default: F}

\item{pal.len}{The number of colours desired in the palette. If the number provided is NULl or is larger than the number of colours available, defaults to the maximum number of colours available. Default: NULL}

\item{nbins}{a numeric value indicating how many equally-spaced values your data should be binned according to. The minimum number of bins is 2, which would bin your data into 3 groups and thus 3 colours. Default: 7}

\item{nquant}{a numeric value indicating how many equally-sized groups your data will be split into. A value of 4 would generate 4 groups and thus 4 colours. Default: 4}

\item{levels}{a character vector that provides an alternate way of specifying levels. Applicable only to character or factor data. If specified, the levels provided here will override those in the data argument. Default: NULL}

\item{ordered}{applicable only if the data needs to be coerced to a factor. If so 'TRUE' will treat the character vector as already in the correct order. Default: F}

\item{squish}{a numeric range (i.e. numeric vector with two values) indicating the range that the data should be squished between. In other words, c(-3, 3) would mean that the most extreme colours in the palette are the same for all values -3 and under, and all values 3 and over, respectively. Default: NULL}

\item{return.legend}{applicable only to character or factor data. If TRUE, then the function will instead return a list of length two: "colours" containing the colour vector, and "legend" containing a named vector of unique colours and their levels. Default: F}
}
\value{
either a character vector of colours of the same length as the input data provided, or, if return.legend is set to TRUE in the case of character or factor data, a list of length two. See "return.legend" for more information.
}
\description{
Returns a vector of colours of the same length as the data provided. The function will inherently deal with vectors of type numeric, character and factor. Colours can be specified in one of three ways. (1) You can provide the name of a valid RColorBrewer palette. To help with this, you can check that the palette exists with brewerland::isBrewerPal(name). You can also see all existing palettes with brewerland::brewerPalNames(). (2) You can provide a valid character vector of
colours. To help with this, you can check that the colours are valid with brewerland::areColours(). Note that here the colours you choose are not limited to those that are in the RColorBrewer palettes. You should however be aware that in this case it is up to you to choose a vector of colours that matches your data type. (3) If you provide neither a palette name or a colour vector, the type of data will be determined internally and a default palette will be chosen accordingly. For all three colour specifications, you can also choose to return binned or quantised colour vectors if you would like numeric values within equally-spaced groups or equally-sized groups to share the same colour.
}
\seealso{
\code{\link[scales]{col_numeric}},\code{\link[scales]{squish}}
}
